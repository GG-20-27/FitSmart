Fix WHOOP data accuracy (live-first) + working weekly averages — NO hard-coded values

Context (do not change):

Auth = JWT in Authorization: Bearer <token> (already works).

Key files:

server/routes.ts → /api/whoop/today, /api/whoop/weekly

server/whoopApiService.ts → WHOOP fetch logic

server/whoopTokenStorage.ts → token refresh/storage

server/jwtAuth.ts → extracts whoopId

server/storage.* → caching helpers (whoop_data table)

Frontend reads /api/whoop/today and shows: recovery, strain, sleep_score (percent), hrv (ms); sleep hours + RHR appear in “Other Insights”.

STRICT RULES (must follow):

Never hard‑code or seed “expected” values for today.

❌ No inserting rows with guessed numbers.

❌ No “fallback to constants” or sample data.

✅ The flow must be Live WHOOP → cache if live unavailable → 404.

Keep user separation: cache keys are per whoop_<id> and date YYYY‑MM‑DD.

Preserve JWT auth & scopes; do not weaken security.

Do not invent “tomorrow” data or future rows.

Tasks

A) /api/whoop/today: live-first, correct field mapping

In routes.ts, update the handler to:

Read userId = getCurrentUserId(req) (must exist).

Try live: const data = await whoopApiService.getTodaysData(userId); if live returns fields, store (upsert) cache as whoop_data_<userId>_<YYYY‑MM‑DD>.

If live fails and cache exists for today, return cache.

Else return 404 { error: 'No WHOOP data available', date }.

Make sure the response maps exactly:

recovery_score → integer %

sleep_score → integer % (NOT hours)

From WHOOP, prefer sleep.score.sleep_performance_percentage (0–100). If missing, omit; do not substitute hours.

sleep_hours → float hours (e.g., 8.5) — from sleep session duration.

strain → float (0–21)

hrv → integer (rmssd ms) — from recovery

resting_heart_rate → integer bpm

Do not convert sleep_hours into percent, and do not swap sleep_score/hours.

Log sources: include [WHOOP TODAY] source=live|cache user=<id> values=….

B) whoopApiService.getTodaysData(userId) corrections

Ensure token retrieval uses the current userId (no defaults).

authHeader(userId) and every downstream call must pass this userId.

Recovery: use /cycle/{id}/recovery → score.recovery_score & score.hrv_rmssd_milli & score.resting_heart_rate.

Sleep:

If recovery includes sleep_id, fetch /activity/sleep/{sleep_id} and use:

score.sleep_performance_percentage → sleep_score (0–100)

Stage summary to compute sleep_hours if needed (sum ms → hours, 1 decimal).

If sleep_id path fails, fallback to /activity/sleep?start=YYYY‑MM‑DD&end=YYYY‑MM‑DD (yesterday→today) and pick most recent non‑nap.

Never set sleep_score from hours.

Strain: from cycle.score.strain.

Return a clean object:

{
  cycle_id, strain, recovery_score, sleep_score, sleep_hours,
  hrv, resting_heart_rate
}


(plus any extras if available, but keep the above accurate.)

C) Cache upsert (today only)

When live succeeds, upsert table whoop_data with:

userId, date, recoveryScore (int), sleepScore (int), strainScore (int*10 or float? → pick **float** column or clearly convert back on read), restingHeartRate (int), lastSync (now)

If schema stores strain as x10 integer today, then:

Store Math.round(strain*10) and divide by 10 on read. Keep this consistent in both write + read.

D) /api/whoop/weekly: return real averages

Use the current userId and fetch the last 7 days via WHOOP API (cycles) OR from cached whoop_data if present; mixing is fine, but no guesses.

Compute:

avgRecovery (mean of recovery_score)

avgStrain

avgSleepScore

avgHRV

Return 200 with those fields; if nothing for the period, return 200 with nulls (do not 404).

E) Time boundaries

Use server TZ consistently; for daily keys, base on Europe/Zurich if that’s used elsewhere (or UTC consistently). Document the choice; apply same when querying API date ranges.

F) Frontend expectations

Main cards: Recovery %, Strain, Sleep Score %, HRV ms.

“Other Insights”: Sleep Hours, Resting HR.

Do not re-order these via code unless data mapping is fixed.

Guardrails / Don’ts

❌ Do not insert manual “today” rows or “tomorrow” rows.

❌ Do not set sleep_score from sleep_hours.

❌ Do not use a default userId; always the JWT’s whoop_<id>.

❌ Do not suppress errors by returning stale cache without logging.

What to change (likely)

server/routes.ts → /api/whoop/today & /api/whoop/weekly control flow and cache write/read normalization.

server/whoopApiService.ts → ensure userId is threaded everywhere; correct sleep_score vs sleep_hours logic; remove any fallback that maps hours→score.

server/storage.* (or wherever whoop_data upsert/read lives) → ensure consistent write/read schema, especially for strainScore scaling.

Logging to add (temporary)

[WHOOP TODAY] user=<id> decided=<live|cache|404>

[WHOOP TODAY] live: rec=<..> sleepScore=<..> sleepHours=<..> strain=<..> hrv=<..> rhr=<..>

[WEEKLY] user=<id> counts: rec=<n> strain=<n> sleepScore=<n> hrv=<n>

Tests (run now)

With valid JWT:

GET /api/whoop/today → 200 with sleep_score % and sleep_hours h both present (if WHOOP has them). No swapped values.

Reload quickly → still 200; if WHOOP rate limits, cache is returned, logged as cache.

GET /api/whoop/weekly?days=7 → 200 with averages, not N/A.

Remove token → both endpoints 401 via requireJWTAuth.

Confirm there are no seeded rows for today in DB that were not produced by fetching live.

Definition of Done

Dashboard shows current Recovery %, Strain, Sleep Score %, HRV ms that match WHOOP live data (within expected API lag), and “Other Insights” shows Sleep Hours + RHR.

Weekly averages render non‑N/A when past 7 days exist.

Logs prove source=live first, then cache only when needed.

No hard-coded or faked values anywhere.